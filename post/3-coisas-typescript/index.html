<!doctype html><html lang=pt-br><head><title>M3 coisas que você deve saber sobre Typescript | Lara Carvalho</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.110.0"><link rel=canonical href=https://laracarvalho.github.io/post/3-coisas-typescript/><link href=/sass/main.min.30077ffe4e9b8b7407cda3bac81bc8b4a99bb5949b13ec489f186cac967144d3.css rel=stylesheet></head><body><div class=flexWrapper><header class=headerWrapper><div class=header><div><a href=/><span class=terminal>laracarvalho@laracarvalho.net ~ $</span></a></div><nav class=headerLinks><ul><li><a href=https://laracarvalho.github.io/about title>~/sobre</a></li><li><a href=https://laracarvalho.github.io/now title>~/agora</a></li><li><a href=https://laracarvalho.github.io/articles title>~/artigos</a></li></ul></nav></div></header><div class=content><main class=main><div class=blogPostWrapper><div><p>Existem 3 features que você deve entender para parar de tratar o Typescript como uma barreira e começar a vê-lo como uma ferramenta. Porque ele é poderosíssimo, e vai muito além de tipar tudo como <code>any</code> pra fazer o console parar de te perturbar.</p><h2 id=1-type-guards>1. Type Guards</h2><p>De acordo com a documentação oficial:</p><blockquote><p>Um type guard é uma expressão que performa uma checagem que garante que o tipo está de acordo com o escopo definido.</p></blockquote><p><em>“A type guard is some expression that performs a runtime check that guarantees the type in some scope.” —</em> <a href=https://www.typescriptlang.org/docs/handbook/advanced-types.html><em>typescriptlang.org</em></a></p><p>O que exatamente isso significa? Com essa ferramenta, podemos afunilar as possíveis tipagens que queremos receber de nossos objetos. Criamos uma forma muito simples de assegurar uma segurança de tipos em nosso código, nada de receber algo que não estávamos esperando.</p><p>Então como podemos criar nossas próprias type guards?</p><p>Vamos ver um exemplo usando a ferramenta typeof, já nativa do Javascript:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Human</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>breathe</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Robot</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>calculate</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createEntity</span>(<span style=color:#a6e22e>entity</span>: <span style=color:#66d9ef>Human</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Robot</span>) {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>entity</span>.<span style=color:#a6e22e>breathe</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;function&#39;</span>) {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>entity</span>.<span style=color:#a6e22e>breathe</span>()
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>entity</span>.<span style=color:#a6e22e>calculate</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;function&#39;</span>) {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>entity</span>.<span style=color:#a6e22e>calculate</span>()
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Ao escrever este código acima, imediatamente recebemos os erros:</p><ul><li><code>Property 'breathe' does not exist on type 'Human | Robot'. Property 'breathe' does not exist on type 'Robot'.(2339)</code></li><li><code>Property 'calculate' does not exist on type 'Human | Robot'. Property 'calculate' does not exist on type 'Human'.(2339)</code></li></ul><p>Então antes mesmo de rodar nosso código, recebemos um erro importante: Alguns dos métodos descritos não podem existir em cada tipo que a minha função recebe. Isso porque meu argumento recebe um tipo de união entre Human e Robot. Então a minha implementação não satisfaz a definição da minha função.</p><p>Vamos criar então nossos type guards para resolver esse problema:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>isHuman</span>(<span style=color:#a6e22e>entity</span>: <span style=color:#66d9ef>Human</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Robot</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>entity</span> <span style=color:#66d9ef>is</span> <span style=color:#a6e22e>Human</span> {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;breathe&#39;</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>entity</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>isRobot</span>(<span style=color:#a6e22e>entity</span>: <span style=color:#66d9ef>Human</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Robot</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>entity</span> <span style=color:#66d9ef>is</span> <span style=color:#a6e22e>Robot</span> {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;calculate&#39;</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>entity</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Com essas funções básicas, eu consigo checar se a propriedade especificada pertence ao objeto.</p><p>E como type guards tem seu próprio escopo, o que acontece dentro de cada bloco de função terá seu check executado sem interferir no que acontece fora dela. O tipo de entity permanece unknown.</p><p>E agora posso reescrever aquela função:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createEntity</span>(<span style=color:#a6e22e>entity</span>: <span style=color:#66d9ef>Human</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Robot</span>) {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>isHuman</span>(<span style=color:#a6e22e>entity</span>)) {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>entity</span>.<span style=color:#a6e22e>breathe</span>()
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>isRobot</span>(<span style=color:#a6e22e>entity</span>)) {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>entity</span>.<span style=color:#a6e22e>calculate</span>()
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=2-keyof>2. Keyof</h2><p>Utilizando essa keyword nós podemos criar dinanismo à nossas funções de uma maneira muito interessante.</p><p>Vamos ver este exemplo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>MenuOptions</span> {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>start</span>: <span style=color:#66d9ef>boolean</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>pause</span>: <span style=color:#66d9ef>boolean</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>stop</span>: <span style=color:#66d9ef>boolean</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ChosenOption</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>keyof</span> <span style=color:#a6e22e>MenuOptions</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>choose</span>&lt;<span style=color:#f92672>T</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ChosenOption</span>&gt;(<span style=color:#a6e22e>key</span>: <span style=color:#66d9ef>T</span>, <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>MenuOptions</span>[<span style=color:#a6e22e>T</span>]) {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010> </span> <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`Logger: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>key</span><span style=color:#e6db74>}</span><span style=color:#e6db74> is set to </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>value</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Aqui temos uma interface que define algumas opções de menu e um tipo que define que opção nós escolhemos a partir da key (chave) da interface, no caso são start, pause, stop.</p><p>E abaixo temos uma função de logs chamada choose que recebe um tipo T genérico, que extende o ChosenOption e um valor que deve se adequar aos valores das keys de MenuOptions. Nesse caso, só temos booleans.</p><p>Então fazendo alguns testes, veremos que:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>choose</span>(<span style=color:#e6db74>&#39;start&#39;</span>, <span style=color:#66d9ef>true</span>)) <span style=color:#75715e>// Logger: start is set to true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>choose</span>(<span style=color:#e6db74>&#39;pause&#39;</span>, <span style=color:#66d9ef>false</span>)) <span style=color:#75715e>// Logger: pause is set to false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>choose</span>(<span style=color:#e6db74>&#39;stop&#39;</span>, <span style=color:#ae81ff>100</span>)) <span style=color:#75715e>// Erro: Argument of type &#39;number&#39; is not assignable to parameter of type &#39;boolean&#39;
</span></span></span></code></pre></div><p>Agora temos uma função que satisfaz a nossa segurança de tipagem e que é extensível a partir da nossa interface.</p><h2 id=3-template-literal-types>3. Template Literal Types</h2><p>Às vezes nós não precisamos de tipos ultra complexos nem criar um monte de definição específica, às vezes nós precisamos de algumas definições em string para mapear IDs, ações externas ao nosso código, tags que devem ser expostas em texto, etc.</p><p>Para isso, podemos usar os template literal types, que são baseados em string literals para expandir nossa forma de trabalhar com strings através de union types.</p><p>Vamos ver alguns exemplos:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Strings</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;greetings&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;welcome_text&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;goodbyes&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Languages</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;pt_br&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;en_us&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;en&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>LocaleGreetings</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>Languages</span><span style=color:#e6db74>}</span><span style=color:#e6db74>_</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>Greetings</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>
</span></span></code></pre></div><p>Agora, de forma simples, temos vários novos tipos preparados a serem usados. Alguns exemplos: pt_br_greetings, en_goodbyes, etc.</p><p>Outro exemplo é quando queremos receber uma informação já bem descritiva. Imagine que preciso receber um evento que modifica dados no meu banco, mas em três diferentes instâncias: quando inserimos um dado, quando atualizamos um dado ou quando deletamos um dado.</p><p>Nosso código usando template literals:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>EventMethods</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;INSERT&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;UPDATE&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;DELETE&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Event</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>action</span>: <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>method</span>: <span style=color:#66d9ef>EventMethods</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Em vez de aceitar apenas strings genéricas e checar dentro do meu código se elas são válidas ou não, eu defino exatamente o que quero receber e deixo o runtime check fazer o trabalho por mim.</p><h2 id=conclusão>Conclusão</h2><p>Espero que tenham curtido o que eu trouxe hoje. Caso queiram ver esse conteúdo em vídeo: <a href="https://www.youtube.com/watch?v=_PT-TBcb5Nw">Video no Youtube</a></p></div></div></main></div><footer class=footer>© 2023 Lara Carvalho, Built with
<a href=https://gohugo.io class=footerLink>Hugo</a> and
<a href=https://github.com/LordMathis/hugo-theme-nightfall class=footerLink>Nightfall</a> theme</footer></div></body></html>